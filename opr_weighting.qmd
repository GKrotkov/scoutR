---
title: "OPR Weighting"
format: pdf
editor: visual
---

```{r libraries}
library(devtools)
load_all()
```

# Gentle OPR Weighting does improve the R^2 slightly for 2022TXIRV

```{r}
library(devtools)
load_all()

event_key <- "2022txirv"

matches <- event_matches(event_key, match_type = "qual")
# order matches before computing design matrix and response
matches <- matches[order(matches$match_number), ]

# apply weighting before computation
# assume the number of weights evenly divides the number of matches
# assume all weights are integers (this assumption could be relaxed)
weights <- c(3, 4, 4, 5)
cuts <- cut(1:nrow(matches), length(weights))

result <- data.frame()
for (i in seq_along(weights)){
    bin <- matches[cuts == cuts[i], ]
    result <- rbind(result, bin[rep(seq_len(nrow(bin)), weights[i]), ])
}

fit <- fit_lineup_lm(
    result, list(red = result$red_score, blue = result$blue_score)
)

null_fit <- fit_lineup_lm(
    matches, list(red = matches$red_score, blue = matches$blue_score)
)

cat("\n", "Null fit adj. R^2:", summary(null_fit)$adj.r.squared, "\n", 
    "Weighted fit adj. R^2:", summary(fit)$adj.r.squared, "\n", 
    "diff:", summary(fit)$adj.r.squared - summary(null_fit)$adj.r.squared, "\n")
```

... but we get singularities if we examine the summary of the coefficients.

# Proving the helper functions work

```{r}
library(devtools)
load_all()

event_key <- "2024paca"

matches <- event_matches(event_key, match_type = "qual")
# order matches before computing design matrix and response
matches <- matches[order(matches$match_number), ]

weights <- c(rep(0, 25), rep(1, 60), rep(25, 24), rep(50, 1))

weighted <- weight_rows(matches, weights)

weighted_fit <- fit_lineup_lm(
    weighted, list(red = weighted$red_score, blue = weighted$blue_score)
)

null_fit <- fit_lineup_lm(
    matches, list(red = matches$red_score, blue = matches$blue_score)
)

cat("\n", "Null fit adj. R^2:", summary(null_fit)$adj.r.squared, "\n", 
    "Weighted fit adj. R^2:", summary(weighted_fit)$adj.r.squared, "\n", 
    "diff:", 
    summary(weighted_fit)$adj.r.squared - summary(null_fit)$adj.r.squared, "\n")
```

# Testing whether throwing out the first two rounds of matches improves OPR

I'll restrict this code to districts because always having 12 qualification matches makes things significantly easier.

```{r}
library(devtools)
load_all()

event_key <- "2023nhgrs"

matches <- event_matches(event_key, match_type = "qual")
matches <- matches[order(matches$match_number), ]

roundlen <- nrow(matches) / 12

# reserve the last 2 matches for testing
test <- weight_rows(matches, c(rep(0, 10), rep(1, 2)))
train <- weight_rows(matches, c(rep(1, 10), rep(0, 2)))

null_fit <- fit_lineup_lm(
    train, list(red = train$red_score, blue = train$blue_score)
)

# throw out the first 2 rounds of matches
weighted <- weight_rows(
    train, c(3, 4, 4, 4, 5)
)

weighted_fit <- fit_lineup_lm(
    weighted, list(red = weighted$red_score, blue = weighted$blue_score)
)

test_design <- lineup_design_matrix(test)
test_design$response <- c(test$blue_score, test$red_score)

preds_null <- predict(null_fit, newdata = test_design)
preds_weighted <- predict(weighted_fit, newdata = test_design)
true_response <- c(test$blue_score, test$red_score)

mse_null <- mean((preds_null - true_response) ^ 2)
mse_weighted <- mean((preds_weighted - true_response) ^ 2)

cat("\n", "Null MSE:", mse_null, "\n", 
    "Weighted MSE:", mse_weighted, "\n")
```

Testing for all districts in 2022

Picking 2022 because that was a generally excellent year for OPR (scoring highly separable and linear)

```{r}
# assume "weights" is a length-5 vector where each index represents an integer
# weight on the importance of a set of 2 "rounds" of matches (each team playing)
# 2 matches, on average
# assume "matches" is a dataframe of qualification matches, *in order*, of
# a district competition (or regional with 12 quals)
compute_mse_diff <- function(matches, weights){
    # assumption: we are looking at districts only
    roundlen <- nrow(matches) / 12

    # reserve the last 2 matches for testing
    test <- weight_rows(matches, c(rep(0, 10), rep(1, 2)))
    train <- weight_rows(matches, c(rep(1, 10), rep(0, 2)))

    null_fit <- fit_lineup_lm(
        train, list(red = train$red_score, blue = train$blue_score)
    )

    # apply given weighting
    weighted <- weight_rows(train, weights)

    weighted_fit <- fit_lineup_lm(
        weighted, list(red = weighted$red_score, blue = weighted$blue_score)
    )

    test_design <- lineup_design_matrix(test)
    test_design$response <- c(test$blue_score, test$red_score)
    
    preds_null <- predict(null_fit, newdata = test_design)
    preds_weighted <- predict(weighted_fit, newdata = test_design)
    true_response <- c(test$blue_score, test$red_score)
    
    mse_null <- mean((preds_null - true_response) ^ 2)
    mse_weighted <- mean((preds_weighted - true_response) ^ 2)
    return(mse_weighted - mse_null)
}
```

```{r}
district_keys <- districts(2019)$key

# remove 2022 ONT and CHS bc they did single-day events
district_keys <- setdiff(district_keys, c("2022ont", "2022chs"))
event_keys <- unlist(sapply(district_keys, district_events, keys = TRUE))
# remove CMP-level events (ONT, MI, TX, and NE have divisions)
event_keys <- setdiff(
    event_keys, event_keys[grep("(mi|ont|tx|ne)cmp$", event_keys)]
)
# 2023 Granite State didn't play the 2nd half of quals
event_keys <- setdiff(event_keys, "2023nhgrs")

matches <- lapply(event_keys, event_matches, match_type = "qual")
# order matches by match number
matches <- lapply(
    matches, function(matches){matches[order(matches$match_number), ]}
)

diffs <- sapply(
    matches, compute_mse_diff, 
    weights = c(3, 4, 4, 4, 5)
)

hist(diffs)
abline(v = mean(diffs), col = "red")

```

Expanding to all district events

```{r}
district_keys <- unlist(sapply(
    setdiff(2009:2024, c(2020, 2021)), function(yr){districts(yr)$key}
))

# remove 2022 ONT and CHS bc they did single-day events
district_keys <- setdiff(district_keys, c("2022ont", "2022chs"))
event_keys <- unlist(sapply(district_keys, district_events, keys = TRUE))
# remove CMP-level events (ONT, MI, TX, and NE have divisions)
event_keys <- setdiff(
    event_keys, event_keys[grep("(mi|on|tx|ne)cmp$", event_keys)]
)
# 2023 Granite State didn't play the 2nd half of quals
event_keys <- setdiff(event_keys, "2023nhgrs")

matches <- lapply(event_keys, event_matches, match_type = "qual")
# order matches by match number
matches <- lapply(
    matches, function(matches){matches[order(matches$match_number), ]}
)

diffs <- sapply(
    matches, compute_mse_diff, 
    weights = c(3, 4, 4, 4, 5)
)

names(diffs) <- event_keys
```

```{r}
data <- diffs[grep("^2018", names(diffs))]

# 2018 was bad for weighting, but all other years have a negative mean
hist(data, main = "Impact of weighting in 2018")
abline(v = mean(data), col = "red")

data <- diffs

hist(data, main = "Impact of weighting from 2012 - 2024")
abline(v = mean(data), col = "red")
```

@TODO update the weighting code to account for non-integer weights
@TODO errors should be normalized by year for cross-year comparisons
@TODO more elegant code for throwing out DCMPs with divisions
@TODO optimization over a grid of all weights
