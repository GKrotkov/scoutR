################
#### ScoutR ####
################

# ScoutR provides an array of useful, event-ready analysis functions for
# data-driven decisionmaking at FRC events.

#' Robot Results
#'
#' Get all the robot-level results available in TBA, under a few assumptions.
#' @param event_code Event code of interest
#' @param match_type One of "all", "qual", or "playoff"
#' @details Assumes that names of robot-level information follow the convention:
#' "(red/blue)_robot_(1/2/3)"
#' @examples
#' mil23_individual <- event_robot_results("2023mil", match_type = "qual")
#' gpr24_individual <- event_robot_results("2024paca")
#'
event_robot_results <- function(event_code, match_type = "all"){
    matches <- event_matches(event_code, match_type = match_type)
    robot_results <- get_multifield_df(matches)
    return(robot_results)
}

#' Event Season History
#'
#' Given an event code, this function returns all a dataframe with all the
#' matches played by every team registered for that event. This is intended
#' for use with the `get_multifield_df`
#' @param event_code TBA-legal event code (ex. "2024paca")
#' @details
#' Checks for match duplication, which will stop execution if TRUE.
#' @examples
#' gpr24 <- event_season_history("2024paca")
#' get_multifield_df(gpr24)
event_season_history <- function(event_code){
    registered_teams <- event_teams(event_code, keys = TRUE)
    registered_teams <- as.numeric(
        substr(registered_teams, 4, nchar(registered_teams))
    )
    year <- as.numeric(substr(event_code, 1, 4))
    matches <- lapply(registered_teams, team_matches, year = year)
    result <- matches %>%
        reduce(full_join)
    # check for duplicated matches
    stopifnot(!any(duplicated(result)))
    return(result)
}

#' Lineup Design Matrix
#'
#' Computes the lineup design matrix (indicator variables one-hot encoding each
#' robot's presence in a match). When used to fit a linear regression through
#' the intercept with scores as the response, the resulting coefficients
#' are equal to OPR. We use the nomenclature "lineups" to reflect NBA "lineup
#' data" which is related to the development of OPR/Calculated Contribution.
#' @param matches Dataframe of matches like output by event_matches
#' @details Assumes match order is irrelevant. Casts the final output to a
#' data.frame because the `lm` function expects a data.frame. Returns blue
#' alliances as a block, and then red alliances. We call this function the
#' "design matrix" because it only includes the indicator variables, and not
#' any of the responses.
#' @examples
#' matches <- event_matches("2023mil", match_type = "qual")
#' matches <- matches[order(matches$match_number), ]
#' design <- lineup_design_matrix(matches)
#' design$score <- c(matches$blue_score, matches$red_score)
#' fit <- lm(score ~ 0 + ., data = design)
#' summary(fit) # retrieves OPRs
lineup_design_matrix <- function(matches){
    lineups <- data.frame(
        robot1 = c(matches$blue1, matches$red1),
        robot2 = c(matches$blue2, matches$red2),
        robot3 = c(matches$blue3, matches$red3)
    )
    # Sort the columns numerically
    teams <- unique(unlist(lineups))
    teams <- teams[order(as.numeric(gsub("^frc", "", teams)))]
    design <- matrix(ncol = length(teams), nrow = nrow(lineups))
    design <- t(apply(lineups, 1, function(row) as.numeric(teams %in% row)))
    colnames(design) <- teams
    return(data.frame(design))
}

#' Fit Lineup Linear Model
#'
#' Computes the lineup design matrix for a given dataframe `lineups`, and then
#' fits a linear model using the given `responses`.
#' @param lineups A dataframe of lineups assumed to have the columns `blue1`,
#' `blue2`, `blue3`, `red1`, `red2`, and `red3`. This can be like a dataframe
#' of matches as output by `event_matches`.
#' @param responses A list of two vectors, `red` and `blue`. Each must be a
#' vector of the same length as the number of rows in `lineups`, representing
#' the response value to fit a linear model to.
#' @param w Weights for WLS fit. Weights will be normalized to be integers
#' and to have the same length as `lineups` has rows.
#' @details Key assumption - the order of `lineups` and the `responses` vector
#' must line up exactly. Otherwise, the fit will be meaningless.
fit_lineup_lm <- function(lineups, responses, w = NULL){
    stopifnot("`responses` must be of length 2" = {length(responses) == 2})
    stopifnot("`responses` must have `red` and `blue` vectors" =
                  "red" %in% names(responses) & "blue" %in% names(responses))
    stopifnot("`responses` vectors must be of the same length as `lineups`" =
                  all(sapply(responses, length) == nrow(lineups)))
    stopifnot("Lineups dataframe input cannot have a column named `response`"
              = {!("response" %in% colnames(lineups))})
    if (is.null(w)){
        w <- rep(1, nrow(lineups))
    }
    w <- normalize_weights(w, len_out = nrow(lineups))
    # double the length of weights to match blue/red alliances
    w <- c(w, w)
    design <- lineup_design_matrix(lineups)
    # the design matrix function does blue first, then red, so we mirror that
    design$response <- c(responses$blue, responses$red)
    return(lm(response ~ 0 + ., data = design, weights = w))
}

#' Fit Event Linear Regression
#'
#' Performs a linear regression through the origin for a given event. With
#' default settings, this will compute OPR; cOPRs can be retrieved through
#' changing the `response` field.
#' @param event_code TBA-legal event code (e.g. "2024paca")
#' @param match_type One of "qual", "playoff", or "all"
#' @param response The response variable of interest for the linear regression.
#' To compute regular OPR, pick "score". Component OPRs can be computed by
#' supplying a string with a different response.
#' @param w Numeric vector indicating the weights to apply to each row
#' @param flip_response_alliance  (bool) if TRUE, uses the blue alliance
#' response for the red alliance design matrix and vice versa. This can be
#' useful for calculating foul contributions to the other alliance or defensive
#' metrics.
#' @return Fitted lm object; to retrieve coefficients call coefficients(fit)
#' @details Assumes that the event matches dataframe follows the convention
#' "(red/blue)_(response)" where (response) is the type of score we are
#' interested in computing an approximation contribution for.
#' @examples
#' fit_event_lr("2024paca")
#' fit_event_lr("2023mil", response = "teleopGamePieceCount")
#' fit_event_lr("2024new", match_type = "all")
#' fit_event_lr("2024paca", response = "foulPoints", flip_response_alliance = T)
fit_event_lr <- function(
        event_code, match_type = "qual", response = "score", w = NULL,
        flip_response_alliance = FALSE){
    matches <- event_matches(event_code, match_type = match_type)
    matches <- matches[order(matches$match_number), ]

    responses <- list(
        red = matches[, paste0("red_", response)][[1]],
        blue = matches[, paste0("blue_", response)][[1]]
    )

    if (flip_response_alliance){
        tmp <- responses
        responses$red <- tmp$blue
        responses$blue <- tmp$red
        rm(tmp)
    }

    return(fit_lineup_lm(matches, responses, w = w))
}
